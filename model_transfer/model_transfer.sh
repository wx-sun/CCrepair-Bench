conda activate mainenv

UDA_VISIBLE_DEVICES=4,5,6,7 python -m vllm.entrypoints.openai.api_server     --host=0.0.0.0     --port=7801     --served-model-name=test     --disable-log-requests     --model /mnt/tenant-home_speed/AIM/model/CodeFuse-CGM-72B     --tokenizer-mode=auto     --tensor-parallel-size=2
	

node_embedding
# 变量
CONTENT=/mnt/tenant-home_speed/ldf/data/CGM/swe-bench-lite/node_content
OUT=/mnt/tenant-home_speed/ldf/data/CGM/swe-bench-lite/node_embedding
MODEL=/mnt/tenant-home_speed/AIM/model/CodeFuse-CGE-Large
SCRIPT=/mnt/tenant-home_speed/ldf/data/CGM/CodeFuse-CGM-main/preprocess_embedding/generate_code_embedding.py

cd /mnt/tenant-home_speed/ldf/data/CGM
mkdir -p shards/gpu{0,1,2,3,4,5,6,7}
for d in shards/gpu{0,1,2,3,4,5,6,7}; do find "$d" -type l -delete; done

# 重新均匀分片（软链）
i=0
for f in "$CONTENT"/*.json; do
  ln -s "$f" "shards/gpu$((i%8))/"
  i=$((i+1))
done

# 继续跑（注意：不带 --overwrite；更稳的批量与分块）
CUDA_VISIBLE_DEVICES=0 python "$SCRIPT" --content-dir shards/gpu0 --out-dir "$OUT" --model-path "$MODEL" --batch-size 16 --max-chars 2048 --skip-doc --device cuda &
CUDA_VISIBLE_DEVICES=1 python "$SCRIPT" --content-dir shards/gpu1 --out-dir "$OUT" --model-path "$MODEL" --batch-size 16 --max-chars 2048 --skip-doc --device cuda &
CUDA_VISIBLE_DEVICES=2 python "$SCRIPT" --content-dir shards/gpu2 --out-dir "$OUT" --model-path "$MODEL" --batch-size 16 --max-chars 2048 --skip-doc --device cuda &
CUDA_VISIBLE_DEVICES=3 python "$SCRIPT" --content-dir shards/gpu3 --out-dir "$OUT" --model-path "$MODEL" --batch-size 16 --max-chars 2048 --skip-doc --device cuda &
CUDA_VISIBLE_DEVICES=4 python "$SCRIPT" --content-dir shards/gpu4 --out-dir "$OUT" --model-path "$MODEL" --batch-size 16 --max-chars 2048 --skip-doc --device cuda &
CUDA_VISIBLE_DEVICES=5 python "$SCRIPT" --content-dir shards/gpu5 --out-dir "$OUT" --model-path "$MODEL" --batch-size 16 --max-chars 2048 --skip-doc --device cuda &
CUDA_VISIBLE_DEVICES=6 python "$SCRIPT" --content-dir shards/gpu6 --out-dir "$OUT" --model-path "$MODEL" --batch-size 16 --max-chars 2048 --skip-doc --device cuda &
CUDA_VISIBLE_DEVICES=7 python "$SCRIPT" --content-dir shards/gpu7 --out-dir "$OUT" --model-path "$MODEL" --batch-size 16 --max-chars 2048 --skip-doc --device cuda &
wait
  "code": {
    "8": "pytest_plugins",
    "9": "# Filename: ah_bootstrap.py\n\n\nimport contextlib\nimport errno\nimport imp\nimport io\nimport locale\nimport os\nimport re\nimport subprocess as sp\nimport sys\n\ntry:\n    from ConfigParser import ConfigParser, RawConfigParser\nexcept ImportError:\n    from configparser import ConfigParser, RawConfigParser\n\n\nif sys.version_info[0] < 3:\n    _str_types = (str, unicode)\n    _text_type = unicode\n    PY3 = False\nelse:\n    _str_types = (str, bytes)\n    _text_type = str\n    PY3 = True\n\n\n# What follows are several import statements meant to deal with install-time\n# issues with either missing or misbehaving pacakges (including making sure\n# setuptools itself is installed):\n\n\n# Some pre-setuptools checks to ensure that either distribute or setuptools >=\n# 0.7 is used (over pre-distribute setuptools) if it is available on the path;\n# otherwise the latest setuptools will be downloaded and bootstrapped with\n# ``ez_setup.py``.  This used to be included in a separate file called\n# setuptools_bootstrap.py; but it was combined into ah_bootstrap.py\ntry:\n    import pkg_resources\n    _setuptools_req = pkg_resources.Requirement.parse('setuptools>=0.7')\n    # This may raise a DistributionNotFound in which case no version of\n    # setuptools or distribute is properly installed\n    _setuptools = pkg_resources.get_distribution('setuptools')\n    if _setuptools not in _setuptools_req:\n        # Older version of setuptools; check if we have distribute; again if\n        # this results in DistributionNotFound we want to give up\n        _distribute = pkg_resources.get_distribution('distribute')\n        if _setuptools != _distribute:\n            # It's possible on some pathological systems to have an old version\n            # of setuptools and distribute on sys.path simultaneously; make\n            # sure distribute is the one that's used\n            sys.path.insert(1, _distribute.location)\n            _distribute.activate()\n            imp.reload(pkg_resources)\nexcept:\n    # There are several types of exceptions that can occur here; if all else\n    # fails bootstrap and use the bootstrapped version\n    from ez_setup import use_setuptools\n    use_setuptools()\n\n\n# typing as a dependency for 1.6.1+ Sphinx causes issues when imported after\n# initializing submodule with ah_boostrap.py\n# See discussion and references in\n# https://github.com/astropy/astropy-helpers/issues/302\n\ntry:\n    import typing   # noqa\nexcept ImportError:\n    pass\n\n\n# Note: The following import is required as a workaround to\n# https://github.com/astropy/astropy-helpers/issues/89; if we don't import this\n# module now, it will get cleaned up after `run_setup` is called, but that will\n# later cause the TemporaryDirectory class defined in it to stop working when\n# used later on by setuptools\ntry:\n    import setuptools.py31compat   # noqa\nexcept ImportError:\n    pass\n\n\n# matplotlib can cause problems if it is imported from within a call of\n# run_setup(), because in some circumstances it will try to write to the user's\n# home directory, resulting in a SandboxViolation.  See\n# https://github.com/matplotlib/matplotlib/pull/4165\n# Making sure matplotlib, if it is available, is imported early in the setup\n# process can mitigate this (note importing matplotlib.pyplot has the same\n# issue)\ntry:\n    import matplotlib\n    matplotlib.use('Agg')\n    import matplotlib.pyplot\nexcept:\n    # Ignore if this fails for *any* reason*\n    pass\n\n\n# End compatibility imports...\n\n\n# In case it didn't successfully import before the ez_setup checks\nimport pkg_resources\n\nfrom setuptools import Distribution\nfrom setuptools.package_index import PackageIndex\nfrom setuptools.sandbox import run_setup\n\nfrom distutils import log\nfrom distutils.debug import DEBUG\n\n\n# TODO: Maybe enable checking for a specific version of astropy_helpers?\nDIST_NAME = 'astropy-helpers'\nPACKAGE_NAME = 'astropy_helpers'\n\n# Defaults for other options\nDOWNLOAD_IF_NEEDED = True\nINDEX_URL = 'https://pypi.python.org/simple'\nUSE_GIT = True\nOFFLINE = False\nAUTO_UPGRADE = True\n\n# A list of all the configuration options and their required types\nCFG_OPTIONS = [\n    ('auto_use', bool), ('path', str), ('download_if_needed', bool),\n    ('index_url', str), ('use_git', bool), ('offline', bool),\n    ('auto_upgrade', bool)\n]\n\n\nclass _Bootstrapper(object):\n    \n\n    def __init__(self, path=None, index_url=None, use_git=None, offline=None,\n                 download_if_needed=None, auto_upgrade=None):\n\n        if path is None:\n            path = PACKAGE_NAME\n\n        if not (isinstance(path, _str_types) or path is False):\n            raise TypeError('path must be a string or False')\n\n        if PY3 and not isinstance(path, _text_type):\n            fs_encoding = sys.getfilesystemencoding()\n            path = path.decode(fs_encoding)  # path to unicode\n\n        self.path = path\n\n        # Set other option attributes, using defaults where necessary\n        self.index_url = index_url if index_url is not None else INDEX_URL\n        self.offline = offline if offline is not None else OFFLINE\n\n        # If offline=True, override download and auto-upgrade\n        if self.offline:\n            download_if_needed = False\n            auto_upgrade = False\n\n        self.download = (download_if_needed\n                         if download_if_needed is not None\n                         else DOWNLOAD_IF_NEEDED)\n        self.auto_upgrade = (auto_upgrade\n                             if auto_upgrade is not None else AUTO_UPGRADE)\n\n        # If this is a release then the .git directory will not exist so we\n        # should not use git.\n        git_dir_exists = os.path.exists(os.path.join(os.path.dirname(__file__), '.git'))\n        if use_git is None and not git_dir_exists:\n            use_git = False\n\n        self.use_git = use_git if use_git is not None else USE_GIT\n        # Declared as False by default--later we check if astropy-helpers can be\n        # upgraded from PyPI, but only if not using a source distribution (as in\n        # the case of import from a git submodule)\n        self.is_submodule = False\n\n    @classmethod\n    def main(cls, argv=None):\n        if argv is None:\n            argv = sys.argv\n\n        config = cls.parse_config()\n        config.update(cls.parse_command_line(argv))\n\n        auto_use = config.pop('auto_use', False)\n        bootstrapper = cls(**config)\n\n        if auto_use:\n            # Run the bootstrapper, otherwise the setup.py is using the old\n            # use_astropy_helpers() interface, in which case it will run the\n            # bootstrapper manually after reconfiguring it.\n            bootstrapper.run()\n\n        return bootstrapper\n\n    @classmethod\n    def parse_config(cls):\n        if not os.path.exists('setup.cfg'):\n            return {}\n\n        cfg = ConfigParser()\n\n        try:\n            cfg.read('setup.cfg')\n        except Exception as e:\n            if DEBUG:\n                raise\n\n            log.error(\n                \"Error reading setup.cfg: {0!r}\\n{1} will not be \"\n                \"automatically bootstrapped and package installation may fail.\"\n                \"\\n{2}\".format(e, PACKAGE_NAME, _err_help_msg))\n            return {}\n\n        if not cfg.has_section('ah_bootstrap'):\n            return {}\n\n        config = {}\n\n        for option, type_ in CFG_OPTIONS:\n            if not cfg.has_option('ah_bootstrap', option):\n                continue\n\n            if type_ is bool:\n                value = cfg.getboolean('ah_bootstrap', option)\n            else:\n                value = cfg.get('ah_bootstrap', option)\n\n            config[option] = value\n\n        return config\n\n    @classmethod\n    def parse_command_line(cls, argv=None):\n        if argv is None:\n            argv = sys.argv\n\n        config = {}\n\n        # For now we just pop recognized ah_bootstrap options out of the\n        # arg list.  This is imperfect; in the unlikely case that a setup.py\n        # custom command or even custom Distribution class defines an argument\n        # of the same name then we will break that.  However there's a catch22\n        # here that we can't just do full argument parsing right here, because\n        # we don't yet know *how* to parse all possible command-line arguments.\n        if '--no-git' in argv:\n            config['use_git'] = False\n            argv.remove('--no-git')\n\n        if '--offline' in argv:\n            config['offline'] = True\n            argv.remove('--offline')\n\n        return config\n\n    def run(self):\n        strategies = ['local_directory', 'local_file', 'index']\n        dist = None\n\n        # First, remove any previously imported versions of astropy_helpers;\n        # this is necessary for nested installs where one package's installer\n        # is installing another package via setuptools.sandbox.run_setup, as in\n        # the case of setup_requires\n        for key in list(sys.modules):\n            try:\n                if key == PACKAGE_NAME or key.startswith(PACKAGE_NAME + '.'):\n                    del sys.modules[key]\n            except AttributeError:\n                # Sometimes mysterious non-string things can turn up in\n                # sys.modules\n                continue\n\n        # Check to see if the path is a submodule\n        self.is_submodule = self._check_submodule()\n\n        for strategy in strategies:\n            method = getattr(self, 'get_{0}_dist'.format(strategy))\n            dist = method()\n            if dist is not None:\n                break\n        else:\n            raise _AHBootstrapSystemExit(\n                \"No source found for the {0!r} package; {0} must be \"\n                \"available and importable as a prerequisite to building \"\n                \"or installing this package.\".format(PACKAGE_NAME))\n\n        # This is a bit hacky, but if astropy_helpers was loaded from a\n        # directory/submodule its Distribution object gets a \"precedence\" of\n        # \"DEVELOP_DIST\".  However, in other cases it gets a precedence of\n        # \"EGG_DIST\".  However, when activing the distribution it will only be\n        # placed early on sys.path if it is treated as an EGG_DIST, so always\n        # do that\n        dist = dist.clone(precedence=pkg_resources.EGG_DIST)\n\n        # Otherwise we found a version of astropy-helpers, so we're done\n        # Just active the found distribution on sys.path--if we did a\n        # download this usually happens automatically but it doesn't hurt to\n        # do it again\n        # Note: Adding the dist to the global working set also activates it\n        # (makes it importable on sys.path) by default.\n\n        try:\n            pkg_resources.working_set.add(dist, replace=True)\n        except TypeError:\n            # Some (much) older versions of setuptools do not have the\n            # replace=True option here.  These versions are old enough that all\n            # bets may be off anyways, but it's easy enough to work around just\n            # in case...\n            if dist.key in pkg_resources.working_set.by_key:\n                del pkg_resources.working_set.by_key[dist.key]\n            pkg_resources.working_set.add(dist)\n\n    @property\n    def config(self):\n        \n\n        return dict((optname, getattr(self, optname))\n                    for optname, _ in CFG_OPTIONS if hasattr(self, optname))\n\n    def get_local_directory_dist(self):\n        \n\n        if not os.path.isdir(self.path):\n            return\n\n        log.info('Attempting to import astropy_helpers from {0} {1!r}'.format(\n                 'submodule' if self.is_submodule else 'directory',\n                 self.path))\n\n        dist = self._directory_import()\n\n        if dist is None:\n            log.warn(\n                'The requested path {0!r} for importing {1} does not '\n                'exist, or does not contain a copy of the {1} '\n                'package.'.format(self.path, PACKAGE_NAME))\n        elif self.auto_upgrade and not self.is_submodule:\n            # A version of astropy-helpers was found on the available path, but\n            # check to see if a bugfix release is available on PyPI\n            upgrade = self._do_upgrade(dist)\n            if upgrade is not None:\n                dist = upgrade\n\n        return dist\n\n    def get_local_file_dist(self):\n        \n\n        if not os.path.isfile(self.path):\n            return\n\n        log.info('Attempting to unpack and import astropy_helpers from '\n                 '{0!r}'.format(self.path))\n\n        try:\n            dist = self._do_download(find_links=[self.path])\n        except Exception as e:\n            if DEBUG:\n                raise\n\n            log.warn(\n                'Failed to import {0} from the specified archive {1!r}: '\n                '{2}'.format(PACKAGE_NAME, self.path, str(e)))\n            dist = None\n\n        if dist is not None and self.auto_upgrade:\n            # A version of astropy-helpers was found on the available path, but\n            # check to see if a bugfix release is available on PyPI\n            upgrade = self._do_upgrade(dist)\n            if upgrade is not None:\n                dist = upgrade\n\n        return dist\n\n    def get_index_dist(self):\n        if not self.download:\n            log.warn('Downloading {0!r} disabled.'.format(DIST_NAME))\n            return None\n\n        log.warn(\n            \"Downloading {0!r}; run setup.py with the --offline option to \"\n            \"force offline installation.\".format(DIST_NAME))\n\n        try:\n            dist = self._do_download()\n        except Exception as e:\n            if DEBUG:\n                raise\n            log.warn(\n                'Failed to download and/or install {0!r} from {1!r}:\\n'\n                '{2}'.format(DIST_NAME, self.index_url, str(e)))\n            dist = None\n\n        # No need to run auto-upgrade here since we've already presumably\n        # gotten the most up-to-date version from the package index\n        return dist\n\n    def _directory_import(self):\n        \n\n        # Return True on success, False on failure but download is allowed, and\n        # otherwise raise SystemExit\n        path = os.path.abspath(self.path)\n\n        # Use an empty WorkingSet rather than the man\n        # pkg_resources.working_set, since on older versions of setuptools this\n        # will invoke a VersionConflict when trying to install an upgrade\n        ws = pkg_resources.WorkingSet([])\n        ws.add_entry(path)\n        dist = ws.by_key.get(DIST_NAME)\n\n        if dist is None:\n            # We didn't find an egg-info/dist-info in the given path, but if a\n            # setup.py exists we can generate it\n            setup_py = os.path.join(path, 'setup.py')\n            if os.path.isfile(setup_py):\n                with _silence():\n                    run_setup(os.path.join(path, 'setup.py'),\n                              ['egg_info'])\n\n                for dist in pkg_resources.find_distributions(path, True):\n                    # There should be only one...\n                    return dist\n\n        return dist\n\n    def _do_download(self, version='', find_links=None):\n        if find_links:\n            allow_hosts = ''\n            index_url = None\n        else:\n            allow_hosts = None\n            index_url = self.index_url\n\n        # Annoyingly, setuptools will not handle other arguments to\n        # Distribution (such as options) before handling setup_requires, so it\n        # is not straightforward to programmatically augment the arguments which\n        # are passed to easy_install\n        class _Distribution(Distribution):\n            def get_option_dict(self, command_name):\n                opts = Distribution.get_option_dict(self, command_name)\n                if command_name == 'easy_install':\n                    if find_links is not None:\n                        opts['find_links'] = ('setup script', find_links)\n                    if index_url is not None:\n                        opts['index_url'] = ('setup script', index_url)\n                    if allow_hosts is not None:\n                        opts['allow_hosts'] = ('setup script', allow_hosts)\n                return opts\n\n        if version:\n            req = '{0}=={1}'.format(DIST_NAME, version)\n        else:\n            req = DIST_NAME\n\n        attrs = {'setup_requires': [req]}\n\n        try:\n            if DEBUG:\n                _Distribution(attrs=attrs)\n            else:\n                with _silence():\n                    _Distribution(attrs=attrs)\n\n            # If the setup_requires succeeded it will have added the new dist to\n            # the main working_set\n            return pkg_resources.working_set.by_key.get(DIST_NAME)\n        except Exception as e:\n            if DEBUG:\n                raise\n\n            msg = 'Error retrieving {0} from {1}:\\n{2}'\n            if find_links:\n                source = find_links[0]\n            elif index_url != INDEX_URL:\n                source = index_url\n            else:\n                source = 'PyPI'\n\n            raise Exception(msg.format(DIST_NAME, source, repr(e)))\n\n    def _do_upgrade(self, dist):\n        # Build up a requirement for a higher bugfix release but a lower minor\n        # release (so API compatibility is guaranteed)\n        next_version = _next_version(dist.parsed_version)\n\n        req = pkg_resources.Requirement.parse(\n            '{0}>{1},<{2}'.format(DIST_NAME, dist.version, next_version))\n\n        package_index = PackageIndex(index_url=self.index_url)\n\n        upgrade = package_index.obtain(req)\n\n        if upgrade is not None:\n            return self._do_download(version=upgrade.version)\n\n    def _check_submodule(self):\n        \n\n        if (self.path is None or\n                (os.path.exists(self.path) and not os.path.isdir(self.path))):\n            return False\n\n        if self.use_git:\n            return self._check_submodule_using_git()\n        else:\n            return self._check_submodule_no_git()\n\n    def _check_submodule_using_git(self):\n        \n\n        cmd = ['git', 'submodule', 'status', '--', self.path]\n\n        try:\n            log.info('Running `{0}`; use the --no-git option to disable git '\n                     'commands'.format(' '.join(cmd)))\n            returncode, stdout, stderr = run_cmd(cmd)\n        except _CommandNotFound:\n            # The git command simply wasn't found; this is most likely the\n            # case on user systems that don't have git and are simply\n            # trying to install the package from PyPI or a source\n            # distribution.  Silently ignore this case and simply don't try\n            # to use submodules\n            return False\n\n        stderr = stderr.strip()\n\n        if returncode != 0 and stderr:\n            # Unfortunately the return code alone cannot be relied on, as\n            # earlier versions of git returned 0 even if the requested submodule\n            # does not exist\n\n            # This is a warning that occurs in perl (from running git submodule)\n            # which only occurs with a malformatted locale setting which can\n            # happen sometimes on OSX.  See again\n            # https://github.com/astropy/astropy/issues/2749\n            perl_warning = ('perl: warning: Falling back to the standard locale '\n                            '(\"C\").')\n            if not stderr.strip().endswith(perl_warning):\n                # Some other unknown error condition occurred\n                log.warn('git submodule command failed '\n                         'unexpectedly:\\n{0}'.format(stderr))\n                return False\n\n        # Output of `git submodule status` is as follows:\n        #\n        # 1: Status indicator: '-' for submodule is uninitialized, '+' if\n        # submodule is initialized but is not at the commit currently indicated\n        # in .gitmodules (and thus needs to be updated), or 'U' if the\n        # submodule is in an unstable state (i.e. has merge conflicts)\n        #\n        # 2. SHA-1 hash of the current commit of the submodule (we don't really\n        # need this information but it's useful for checking that the output is\n        # correct)\n        #\n        # 3. The output of `git describe` for the submodule's current commit\n        # hash (this includes for example what branches the commit is on) but\n        # only if the submodule is initialized.  We ignore this information for\n        # now\n        _git_submodule_status_re = re.compile(\n            '^(?P<status>[+-U ])(?P<commit>[0-9a-f]{40}) '\n            '(?P<submodule>\\S+)( .*)?$')\n\n        # The stdout should only contain one line--the status of the\n        # requested submodule\n        m = _git_submodule_status_re.match(stdout)\n        if m:\n            # Yes, the path *is* a git submodule\n            self._update_submodule(m.group('submodule'), m.group('status'))\n            return True\n        else:\n            log.warn(\n                'Unexpected output from `git submodule status`:\\n{0}\\n'\n                'Will attempt import from {1!r} regardless.'.format(\n                    stdout, self.path))\n            return False\n\n    def _check_submodule_no_git(self):\n        \n\n        gitmodules_path = os.path.abspath('.gitmodules')\n\n        if not os.path.isfile(gitmodules_path):\n            return False\n\n        # This is a minimal reader for gitconfig-style files.  It handles a few of\n        # the quirks that make gitconfig files incompatible with ConfigParser-style\n        # files, but does not support the full gitconfig syntax (just enough\n        # needed to read a .gitmodules file).\n        gitmodules_fileobj = io.StringIO()\n\n        # Must use io.open for cross-Python-compatible behavior wrt unicode\n        with io.open(gitmodules_path) as f:\n            for line in f:\n                # gitconfig files are more flexible with leading whitespace; just\n                # go ahead and remove it\n                line = line.lstrip()\n\n                # comments can start with either # or ;\n                if line and line[0] in (':', ';'):\n                    continue\n\n                gitmodules_fileobj.write(line)\n\n        gitmodules_fileobj.seek(0)\n\n        cfg = RawConfigParser()\n\n        try:\n            cfg.readfp(gitmodules_fileobj)\n        except Exception as exc:\n            log.warn('Malformatted .gitmodules file: {0}\\n'\n                     '{1} cannot be assumed to be a git submodule.'.format(\n                         exc, self.path))\n            return False\n\n        for section in cfg.sections():\n            if not cfg.has_option(section, 'path'):\n                continue\n\n            submodule_path = cfg.get(section, 'path').rstrip(os.sep)\n\n            if submodule_path == self.path.rstrip(os.sep):\n                return True\n\n        return False\n\n    def _update_submodule(self, submodule, status):\n        if status == ' ':\n            # The submodule is up to date; no action necessary\n            return\n        elif status == '-':\n            if self.offline:\n                raise _AHBootstrapSystemExit(\n                    \"Cannot initialize the {0} submodule in --offline mode; \"\n                    \"this requires being able to clone the submodule from an \"\n                    \"online repository.\".format(submodule))\n            cmd = ['update', '--init']\n            action = 'Initializing'\n        elif status == '+':\n            cmd = ['update']\n            action = 'Updating'\n            if self.offline:\n                cmd.append('--no-fetch')\n        elif status == 'U':\n            raise _AHBootstrapSystemExit(\n                'Error: Submodule {0} contains unresolved merge conflicts.  '\n                'Please complete or abandon any changes in the submodule so that '\n                'it is in a usable state, then try again.'.format(submodule))\n        else:\n            log.warn('Unknown status {0!r} for git submodule {1!r}.  Will '\n                     'attempt to use the submodule as-is, but try to ensure '\n                     'that the submodule is in a clean state and contains no '\n                     'conflicts or errors.\\n{2}'.format(status, submodule,\n                                                        _err_help_msg))\n            return\n\n        err_msg = None\n        cmd = ['git', 'submodule'] + cmd + ['--', submodule]\n        log.warn('{0} {1} submodule with: `{2}`'.format(\n            action, submodule, ' '.join(cmd)))\n\n        try:\n            log.info('Running `{0}`; use the --no-git option to disable git '\n                     'commands'.format(' '.join(cmd)))\n            returncode, stdout, stderr = run_cmd(cmd)\n        except OSError as e:\n            err_msg = str(e)\n        else:\n            if returncode != 0:\n                err_msg = stderr\n\n        if err_msg is not None:\n            log.warn('An unexpected error occurred updating the git submodule '\n                     '{0!r}:\\n{1}\\n{2}'.format(submodule, err_msg,\n                                               _err_help_msg))\n\nclass _CommandNotFound(OSError):\n    \n\n\ndef run_cmd(cmd):\n    \n\n    try:\n        p = sp.Popen(cmd, stdout=sp.PIPE, stderr=sp.PIPE)\n        # XXX: May block if either stdout or stderr fill their buffers;\n        # however for the commands this is currently used for that is\n        # unlikely (they should have very brief output)\n        stdout, stderr = p.communicate()\n    except OSError as e:\n        if DEBUG:\n            raise\n\n        if e.errno == errno.ENOENT:\n            msg = 'Command not found: `{0}`'.format(' '.join(cmd))\n            raise _CommandNotFound(msg, cmd)\n        else:\n            raise _AHBootstrapSystemExit(\n                'An unexpected error occurred when running the '\n                '`{0}` command:\\n{1}'.format(' '.join(cmd), str(e)))\n\n\n    # Can fail of the default locale is not configured properly.  See\n    # https://github.com/astropy/astropy/issues/2749.  For the purposes under\n    # consideration 'latin1' is an acceptable fallback.\n    try:\n        stdio_encoding = locale.getdefaultlocale()[1] or 'latin1'\n    except ValueError:\n        # Due to an OSX oddity locale.getdefaultlocale() can also crash\n        # depending on the user's locale/language settings.  See:\n        # http://bugs.python.org/issue18378\n        stdio_encoding = 'latin1'\n\n    # Unlikely to fail at this point but even then let's be flexible\n    if not isinstance(stdout, _text_type):\n        stdout = stdout.decode(stdio_encoding, 'replace')\n    if not isinstance(stderr, _text_type):\n        stderr = stderr.decode(stdio_encoding, 'replace')\n\n    return (p.returncode, stdout, stderr)\n\n\ndef _next_version(version):\n    \n\n    if hasattr(version, 'base_version'):\n        # New version parsing from setuptools >= 8.0\n        if version.base_version:\n            parts = version.base_version.split('.')\n        else:\n            parts = []\n    else:\n        parts = []\n        for part in version:\n            if part.startswith('*'):\n                break\n            parts.append(part)\n\n    parts = [int(p) for p in parts]\n\n    if len(parts) < 3:\n        parts += [0] * (3 - len(parts))\n\n    major, minor, micro = parts[:3]\n\n    return '{0}.{1}.{2}'.format(major, minor + 1, 0)\n\n\nclass _DummyFile(object):\n    \n\n    errors = ''  # Required for Python 3.x\n    encoding = 'utf-8'\n\n    def write(self, s):\n        pass\n\n    def flush(self):\n        pass\n\n\n@contextlib.contextmanager\ndef _silence():\n    \n\n    old_stdout = sys.stdout\n    old_stderr = sys.stderr\n    sys.stdout = _DummyFile()\n    sys.stderr = _DummyFile()\n    exception_occurred = False\n    try:\n        yield\n    except:\n        exception_occurred = True\n        # Go ahead and clean up so that exception handling can work normally\n        sys.stdout = old_stdout\n        sys.stderr = old_stderr\n        raise\n\n    if not exception_occurred:\n        sys.stdout = old_stdout\n        sys.stderr = old_stderr\n\n\n_err_help_msg = \n\n\nclass _AHBootstrapSystemExit(SystemExit):\n    def __init__(self, *args):\n        if not args:\n            msg = 'An unknown problem occurred bootstrapping astropy_helpers.'\n        else:\n            msg = args[0]\n\n        msg += '\\n' + _err_help_msg\n\n        super(_AHBootstrapSystemExit, self).__init__(msg, *args[1:])\n\n\nBOOTSTRAPPER = _Bootstrapper.main()\n\n\ndef use_astropy_helpers(**kwargs):\n    \n\n    global BOOTSTRAPPER\n\n    config = BOOTSTRAPPER.config\n    config.update(**kwargs)\n\n    # Create a new bootstrapper with the updated configuration and run it\n    BOOTSTRAPPER = _Bootstrapper(**config)\n    BOOTSTRAPPER.run()",